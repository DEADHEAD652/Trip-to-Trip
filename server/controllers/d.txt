// const slugify = require("slugify");
// const multer = require("multer");
// const sharp = require("sharp");

// // MULTER CONFIGUREATION
// const multerStorage = multer.memoryStorage();

// const multerFilter = (req, file, cb) => {
//   if (file.mimetype.startsWith("image" || "pdf")) {
//     cb(null, true);
//   } else {
//     cb(new AppError("Not an image. Please upload only images", 400), false);
//   }
// };

// const upload = multer({
//   storage: multerStorage,
//   fileFilter: multerFilter,
// });

// exports.uploadGuideImages = upload.fields([
//   { name: "photo", maxCount: 1 },
//   { name: "guidelicense", maxCount: 1 },
// ]);

// // RESIZE UPLOADED IMAGES
// exports.resizeImages = async (req, res, next) => {
//   if (!req.files.photo || !req.files.guidelicense) return next();

//   const guideName = slugify(req.body.name);

//   // 1) photo
//   req.files.photo.filename = `guide-${guideName}-${Date.now()}-photo.jpeg`;

//   sharp(req.files.photo[0].buffer)
//     .resize(2000, 1333)
//     .toFormat("jpeg")
//     .jpeg({ quality: 90 });

//   // 2) guidelicense

//   req.files.guidelicense.filename = `guide-${guideName}-${Date.now()}-guidelicense.pdf`;
//   sharp(req.files.guidelicense[0].buffer).toFormat("pdf");
// };















try {
    let form = new formidable.IncomingForm({ multiples: true });
    form.keepExtensions = true;
    form.parse(req, (err, fields, files) => {
      if (err) {
        return res.status(400).json({
          err: "Files could not be uploaded",
        });
      }
      // cloudinary.uploader.upload(files.photo.path, (err, result) => {
      //   if (err) return res.status(400).json({ err });
      //   else {
      //     const { url } = result;
      //   }
      // });
      let guides = new Guides(fields);
      if (files.guidelicense && files.photo) {
        if (files.guidelicense.size > 1000000) {
          return res.status(400).json({ error: "file should be les than 1mb" });
        }
        if (files.photo.size > 1000000) {
          return res.status(400).json({ error: "file should be les than 1mb" });
        }
        const files = cloudinary.uploader.upload(files.photo.path, {
          public_id: guide_photo,
        });
        const {
          name,
          email,
          password,
          address,
          cnic,
          phonenumber,
          isAvalaible,
        } = fields;
        if (
          (!name || !email || !password || !address || !phonenumber || !cnic,
          !isAvalaible)
        ) {
          return res.status(400).json({
            error: "all fields are required!",
          });
        }
        guides.guidelicense.data = fs.readFileSync(files.guidelicense.filepath);
        guides.guidelicense.contentType = files.guidelicense.mimetype;
        guides.photo.data = fs.readFileSync(files.photo.filepath);
        guides.photo.contentType = files.photo.mimetype;
      }
      guides.save((err, result) => {
        if (err) {
          return res.status(400).json({ err });
        }
        res.json(result);
      });
    });
  } catch (e) {
    res.status(500).send(e);
  }






  //update
   try {
    let form = new formidable.IncomingForm();
    form.keepExtensions = true;
    form.parse(req, (err, fields, files) => {
      if (err) {
        res.status(400).send("error");
      }

      let tours = req.tours;
      tours = _.extend(tours, fields);
      if (
        files.imageCover &&
        files.image1 &&
        files.image2 &&
        files.image1 &&
        files.image3
      ) {
        if (files.imageCover.size > 1000000) {
          return res.status(400).json({ error: "file should be les than 1mb" });
        }
        if (files.image1.size > 1000000) {
          return res.status(400).json({ error: "file should be les than 1mb" });
        }
        if (files.image2.size > 1000000) {
          return res.status(400).json({ error: "file should be les than 1mb" });
        }
        if (files.image3.size > 1000000) {
          return res.status(400).json({ error: "file should be les than 1mb" });
        }

        tours.imageCover.data = fs.readFileSync(files.imageCover.filepath);
        tours.imageCover.contentType = files.imageCover.mimetype;
        tours.image1.data = fs.readFileSync(files.image1.filepath);
        tours.image1.contentType = files.image1.mimetype;
        tours.image2.data = fs.readFileSync(files.image2.filepath);
        tours.image2.contentType = files.image2.mimetype;
        tours.image3.data = fs.readFileSync(files.image3.filepath);
        tours.image3.contentType = files.image3.mimetype;
      }
    });
    const tour = await Tour.findByIdAndUpdate(
      { _id: req.params.id },
      { $set: req.body },
      { new: true }
    );

    if (!tour) {
      res.status(404).send("tour not found");
    }
    await tour.save();
    res.status(201).send(tour);
  } catch (e) {
    res.status(500).send(e);
  }









//user signup



  let form = new formidable.IncomingForm({ multiples: true });
  form.keepExtensions = true;

  form.parse(req, (err, fields, files) => {
    if (err) {
      return res.status(400).json({
        error: "Image could not be uploaded",
      });
    }
    const mycloud = cloudinary.uploader.upload(
      files.avatar.filepath,
      (error, result) => {
        if (error) {
          return res.status(400).json({
            error: "Image could not be uploaded to cloudinary",
          });
        }
      }
    );
    const { name, email, password, avatar } = req.body;

    const user = User.create({
      name,
      email,
      password,
      avatar,
    });

    res.status(201).send(user);
  });










  let guide = Guides.findById(req.params.userID);
  //deleting image and guidelicence
  cloudinary.uploader.destroy(guide.Avatarcloudinary_id);
  cloudinary.uploader.destroy(guide.Guidelicensecloudinary_id);
  //upload new files to cloudinary
  // let avatar = cloudinary.uploader.upload(req.files.avatar[0].path);
  // console.log(avatar);
  // let guidelicense = cloudinary.uploader.upload(req.files.guidelicense[0].path);
  let data = {
    fullname: req.body.fullname || guide.fullname,
    password: req.body.password,
    email: req.body.email,
    address: req.body.address || guide.address,
    phonenumber: req.body.phonenumber || guide.phonenumber,
    cnic: req.body.cnic || guide.cnic,
    isAvalaible: req.body.isAvalaible || guide.isAvalaible,
    // avatar: avatar.url || guide.avatar,
    // guidelicense: guidelicense.url || guide.guidelicense,



    // let user = User.findById(req.params.userID);
  // // Upload image to cloudinary
  // let result = cloudinary.uploader.upload(req.file.path);
  // let data = {
  //   fullname: req.body.fullname || user.fullname,
  //   password: req.body.password,
  //   email: req.body.email,
  //   avatar: result.secure_url || user.avatar,
  // };
  // user = User.findByIdAndUpdate(req.params.userID, data, {
  //   new: true,
  // });
  // res.json(user);



  //jwt signup
  const express = require('express');
const router = express.Router();
const jwt = require('jsonwebtoken');
const passport = require('passport');
const bcrypt = require('bcryptjs');
const multer = require('multer');
const cloudinary = require('cloudinary');

// Configure Cloudinary
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET
});

// Multer config for file upload
const upload = multer({ dest: 'temp/' });

router.post('/signup', upload.single('avatar'), async (req, res, next) => {
  try {
    // Destructure the request body
    const { fullName, email, password } = req.body;
  
    // Check for required fields
    if (!fullName || !email || !password) {
      return res.status(400).json({ message: 'All fields are required' });
    }
  
    // Check if user already exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'User already exists' });
    }
  
    // Hash the password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);
  
    // Create a new user object
    const user = new User({
      fullName,
      email,
      password: hashedPassword
    });
  
    // Check if avatar was uploaded
    if (req.file) {
      // Upload avatar to Cloudinary
      const result = await cloudinary.v2.uploader.upload(req.file.path);
  
      // Add avatar URL to user object
      user.avatar = result.secure_url;
    }
  
    // Save the user to the database
    await user.save();
  
    // Sign the JWT
    const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET);
  
    // Send the response
    res.json({ token });
  } catch (err) {
    next(err);
  }
})










//update
try {
    const {
      fullname,
      email,
      password,
      address,
      phonenumber,
      cnic,
      isAvalaible,
    } = req.body;

    array.forEach((element) => {});
    if (req.files.avatar && req.files.avatar[0]) {
      let avatar = await cloudinary.uploader.upload(req.files.avatar[0].path);

      fs.unlink(req.files.avatar[0].path, (err) => {
        if (err) {
          console.log(err);
        }
      });
    }
    let guidelicense = await cloudinary.uploader.upload(
      req.files.guidelicense[0].path
    );

    fs.unlink(req.files.guidelicense[0].path, (err) => {
      if (err) {
        console.log(err);
      }
    });
    const guide = await Guides.findByIdAndUpdate(req.params.userID, {
      fullname,
      email,
      password,
      address,
      phonenumber,
      cnic,
      isAvalaible,
      avatar: avatar.url,
      guidelicense: guidelicense.url,
    });
    await guide.save();
    res.status(200).json(guide);
  } catch (error) {
    console.log(error);

    res.status(500).json({ message: error.message });
  }



  ///auth sign in
  const { email, password } = req.body;
  try {
    const userExist = await User.findOne({ email: email });
    if (!userExist) {
      return res.status(404).json({ message: "User does not exist" });
    }

    bcrypt.compare(password, userExist.password, (err, isMatch) => {
      if (err) {
        return res.status(500).json({ message: err.message });
      }
      if (isMatch) {
        const payload = { id: userExist._id };
        const token = jwt.sign(payload, process.env.Jwt_Secret, {
          expiresIn: "7d",
        });
        return res.status(200).json({ user: userExist, token });
      } else {
        return res.status(400).json({ message: "Invalid credentials" });
      }
    });
  } catch (err) {
    return res.status(500).json({ message: err.message });
  }